From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: wangxyper <wangxyper@163.com>
Date: Sat, 8 Apr 2023 17:57:20 +0800
Subject: [PATCH] Refactor to Moka and add missing files


diff --git a/src/main/java/co/earthme/hearse/concurrent/WorkStealingThreadPool.java b/src/main/java/co/earthme/hearse/concurrent/WorkStealingThreadPool.java
deleted file mode 100644
index 42d63f105e35e622517378f07aa75e1951d620c5..0000000000000000000000000000000000000000
--- a/src/main/java/co/earthme/hearse/concurrent/WorkStealingThreadPool.java
+++ /dev/null
@@ -1,244 +0,0 @@
-package co.earthme.hearse.concurrent;
-
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-
-import java.util.*;
-import java.util.concurrent.*;
-import java.util.concurrent.atomic.*;
-import java.util.concurrent.locks.*;
-
-public class WorkStealingThreadPool{
-    private final Executor packaged = new PackagedExecutor(this);
-    private final List<WorkerThread> workers = new ArrayList<>();
-    private final StampedLock workersLock = new StampedLock();
-    private int lastPostedPos = 0;
-    private final WorkerThreadFactory factory;
-
-    public WorkStealingThreadPool(int nThreads, WorkerThreadFactory factory){
-        this.factory = factory;
-        this.runWorkers(nThreads);
-    }
-
-    private void sendStopToAll(){
-        final long stamp = this.workersLock.readLock();
-        try {
-            for (WorkerThread workerThread : this.workers){
-                workerThread.sendStop();
-            }
-        }finally {
-            this.workersLock.unlockRead(stamp);
-        }
-    }
-
-    @NotNull
-    public Executor getPackaged() {
-        return this.packaged;
-    }
-
-    private void runWorkers(int threadCount){
-        for (int i = 0; i < threadCount; i++) {
-            final WorkerThread workerThread = new WorkerThread();
-            final long stamp = this.workersLock.writeLock();
-            try {
-                this.workers.add(workerThread);
-            }finally {
-                this.workersLock.unlockWrite(stamp);
-            }
-            workerThread.start();
-        }
-    }
-
-    public void awaitTasks(){
-        final long stamp = this.workersLock.readLock();
-        try {
-            for (WorkerThread workerThread : this.workers){
-                workerThread.awaitTasks();
-            }
-        }finally {
-            this.workersLock.unlockRead(stamp);
-        }
-    }
-
-    public void postTask(@NotNull Runnable task){
-        long stamp = this.workersLock.tryOptimisticRead();
-        if (this.workersLock.validate(stamp)){
-            int workerIndex;
-            synchronized (this.workers){
-                if (this.lastPostedPos+1 >= this.workers.size()){
-                    this.lastPostedPos = 0;
-                }
-                workerIndex = this.lastPostedPos++;
-            }
-            final WorkerThread workerThread = this.workers.get(workerIndex);
-            workerThread.postRunnable(task);
-            return;
-        }
-        stamp = this.workersLock.readLock();
-        try {
-            int workerIndex;
-            synchronized (this.workers){
-                if (this.lastPostedPos+1 >= this.workers.size()){
-                    this.lastPostedPos = 0;
-                }
-                workerIndex = this.lastPostedPos++;
-            }
-            final WorkerThread workerThread = this.workers.get(workerIndex);
-            workerThread.postRunnable(task);
-        }finally {
-            this.workersLock.unlockRead(stamp);
-        }
-    }
-
-    public <T> Future<T> postTask(@NotNull Callable<T> task){
-        final FutureTask<T> newTask = new FutureTask<>(task);
-        this.postTask(newTask);
-        return newTask;
-    }
-
-    private class WorkerThread implements Runnable {
-        private final Deque<Runnable> tasks = new ArrayDeque<>();
-        private final ReadWriteLock taskLock = new ReentrantReadWriteLock();
-        private final AtomicBoolean runningTask = new AtomicBoolean();
-        private final Thread worker = WorkStealingThreadPool.this.factory.getNewThread(this);
-
-        private volatile boolean shouldRun = false;
-        private volatile boolean running = false;
-
-
-        public void postRunnable(@NotNull Runnable task){
-            this.taskLock.writeLock().lock();
-            try {
-                this.tasks.add(task);
-            }finally {
-                this.taskLock.writeLock().unlock();
-            }
-        }
-
-        public void sendStop(){
-            this.shouldRun = false;
-            LockSupport.unpark(this.worker);
-        }
-
-        public void awaitTerminate(){
-            while (this.running){
-                LockSupport.parkNanos(100000);
-            }
-        }
-
-        public void awaitTasks(){
-            while (this.runningTask.get()){
-                LockSupport.parkNanos(100000);
-            }
-        }
-
-        @Override
-        public void run(){
-            Runnable curTask;
-            Runnable stole;
-            while (this.shouldRun || !this.tasks.isEmpty()){
-                if ((curTask = this.pollTask(false)) != null){
-                    this.runningTask.set(true);
-                    try {
-                        curTask.run();
-                    }catch (Exception e){
-                        e.printStackTrace();
-                    }finally {
-                        this.runningTask.set(false);
-                    }
-                    continue;
-                }
-
-                if ((stole = this.steal()) != null){
-                    try {
-                        stole.run();
-                    }catch (Exception e){
-                        e.printStackTrace();
-                    }
-                    continue;
-                }
-
-                LockSupport.parkNanos("FREE WAITING",1000000);
-            }
-            this.running = false;
-        }
-
-        public void start(){
-            this.running = true;
-            this.shouldRun = true;
-            this.worker.start();
-        }
-
-        @Nullable
-        private Runnable steal(){
-            long stamp = WorkStealingThreadPool.this.workersLock.tryOptimisticRead();
-            if (WorkStealingThreadPool.this.workersLock.validate(stamp)){
-                for (WorkerThread workerThread : WorkStealingThreadPool.this.workers){
-                    if (workerThread.equals(this)){
-                        continue;
-                    }
-                    if (workerThread.isCurrentThreadRunningTask() && workerThread.getQueuedTaskCount() >= 1){
-                        return workerThread.pollTask(true);
-                    }
-                }
-                return null;
-            }
-
-            stamp = WorkStealingThreadPool.this.workersLock.readLock();
-            try {
-                for (WorkerThread workerThread : WorkStealingThreadPool.this.workers){
-                    if (workerThread.equals(this)){
-                        continue;
-                    }
-                    if (workerThread.isCurrentThreadRunningTask() && workerThread.getQueuedTaskCount() >= 1){
-                        return workerThread.pollTask(true);
-                    }
-                }
-                return null;
-            }finally {
-                WorkStealingThreadPool.this.workersLock.unlockRead(stamp);
-            }
-        }
-
-
-        protected int getQueuedTaskCount(){
-            this.taskLock.readLock().lock();
-            try {
-                return this.tasks.size();
-            }finally {
-                this.taskLock.readLock().unlock();
-            }
-        }
-
-        protected boolean isCurrentThreadRunningTask(){
-            return this.runningTask.get();
-        }
-
-        @Nullable
-        protected Runnable pollTask(boolean tail){
-            Runnable polledRunnable;
-
-            this.taskLock.writeLock().lock();
-            try {
-                polledRunnable = tail ? this.tasks.pollLast() : this.tasks.pollFirst();
-            }finally {
-                this.taskLock.writeLock().unlock();
-            }
-
-            return polledRunnable;
-        }
-    }
-
-    public static class PackagedExecutor implements Executor{
-        private final WorkStealingThreadPool internalPool;
-
-        public PackagedExecutor(@NotNull WorkStealingThreadPool internalPool) {
-            this.internalPool = internalPool;
-        }
-
-        @Override
-        public void execute(@NotNull Runnable command) {
-            this.internalPool.postTask(command);
-        }
-    }
-}
\ No newline at end of file
diff --git a/src/main/java/co/earthme/hearse/concurrent/WorkerThreadFactory.java b/src/main/java/co/earthme/hearse/concurrent/WorkerThreadFactory.java
deleted file mode 100644
index 5ffca8dac85fcbe50a4445ebc375b33d8228d690..0000000000000000000000000000000000000000
--- a/src/main/java/co/earthme/hearse/concurrent/WorkerThreadFactory.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package co.earthme.hearse.concurrent;
-
-import co.earthme.hearse.concurrent.thread.WorkerThread;
-
-public interface WorkerThreadFactory {
-    WorkerThread getNewThread(Runnable task);
-}
diff --git a/src/main/java/co/earthme/hearse/workers/WorkerThreadPoolManager.java b/src/main/java/co/earthme/hearse/workers/WorkerThreadPoolManager.java
deleted file mode 100644
index 8cb0d00fb3cd4282873c8b8db88c87e59f8ef9de..0000000000000000000000000000000000000000
--- a/src/main/java/co/earthme/hearse/workers/WorkerThreadPoolManager.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package co.earthme.hearse.workers;
-
-import co.earthme.hearse.concurrent.WorkerThreadPoolExecutor;
-import com.google.common.collect.Maps;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ForkJoinPool;
-import java.util.concurrent.TimeUnit;
-
-public class WorkerThreadPoolManager {
-    private final Map<String,WorkerThreadPoolExecutor> managedWorkers = Maps.newConcurrentMap();
-
-    public void addWorker(String bound,WorkerThreadPoolExecutor worker){
-        this.managedWorkers.put(bound,worker);
-    }
-
-    public void shutdownAll() throws InterruptedException {
-        for (WorkerThreadPoolExecutor worker : this.managedWorkers.values()){
-            if (!worker.isShutdown()){
-                worker.getQueue().clear(); //Clear the tasks.We don't need wait them
-                worker.shutdown();
-                while (worker.awaitTermination(100, TimeUnit.MILLISECONDS)); {}
-            }
-        }
-    }
-
-    @Deprecated
-    public Map<String, WorkerThreadPoolExecutor> getManagedWorkers() {
-        return Maps.newHashMap(this.managedWorkers);
-    }
-
-    @Deprecated
-    public WorkerThreadPoolExecutor getTargetWorker(String bound){
-        return this.managedWorkers.get(bound);
-    }
-
-    public Map<String,List<Runnable>> shutdownAllNow(){
-        final Map<String,List<Runnable>> ret = Maps.newHashMap();
-        for (Map.Entry<String,WorkerThreadPoolExecutor> entry : this.managedWorkers.entrySet()){
-            final String workerName = entry.getKey();
-            final WorkerThreadPoolExecutor worker = entry.getValue();
-            if (!worker.isShutdown()){
-                try {
-                    final List<Runnable> taskNotRunned = worker.shutdownNow();
-                    ret.put(workerName,taskNotRunned);
-                }catch (Exception e){
-                    e.printStackTrace();
-                }
-            }
-        }
-        return ret;
-    }
-
-    public void shutdownAll(long singleWorkerAwaitTimeOutCount) throws InterruptedException {
-        long counter = singleWorkerAwaitTimeOutCount;
-        for (WorkerThreadPoolExecutor worker : this.managedWorkers.values()){
-            if (!worker.isShutdown()){
-                worker.shutdown();
-                while (worker.awaitTermination(1, TimeUnit.MILLISECONDS)) {
-                    if (counter == 0){
-                        break;
-                    }
-                    counter--;
-                }
-                counter = singleWorkerAwaitTimeOutCount;
-            }
-        }
-    }
-}
diff --git a/src/main/java/com/kiocg/ChunkHot.java b/src/main/java/com/kiocg/ChunkHot.java
new file mode 100644
index 0000000000000000000000000000000000000000..149d1e989295b275af9a9f71443f5212792ead07
--- /dev/null
+++ b/src/main/java/com/kiocg/ChunkHot.java
@@ -0,0 +1,48 @@
+package com.kiocg;
+
+public class ChunkHot {
+    private static final int TIMES_LENGTH = 10;
+    private static int index = -1;
+    private static final Object GLOBAL_LOCK = new Object();
+
+    private final long[] times = new long[TIMES_LENGTH];
+    private long total;
+    private long nanos;
+
+    public static void nextTick() {
+        synchronized (GLOBAL_LOCK){
+            index = ++index % TIMES_LENGTH;
+        }
+    }
+
+    public void start() {
+        synchronized (GLOBAL_LOCK){ //Hearse -- add synchronized to ensure thread safe
+            total -= times[index];
+            times[index] = 0L;
+        }
+    }
+
+    public void stop() {
+        synchronized (GLOBAL_LOCK){ //Hearse -- add synchronized to ensure thread safe
+            total += times[index];
+        }
+    }
+
+    public void startTicking() {
+        synchronized (GLOBAL_LOCK){ //Hearse -- add synchronized to ensure thread safe
+            nanos = System.nanoTime();
+        }
+    }
+
+    public void stopTickingAndCount() {
+        synchronized (GLOBAL_LOCK){ //Hearse -- add synchronized to ensure thread safe
+            times[index] += Math.min(System.nanoTime() - nanos, 1000000L);
+        }
+    }
+
+    public long getAverage() {
+        synchronized (GLOBAL_LOCK){ //Hearse -- add synchronized to ensure thread safe
+            return total / ((long) TIMES_LENGTH * 20L);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index 34372dac2a1ce5a9d93ff1fc02be102825d1623c..3e4fe3b63b05d10e5bd245df2ec18b12f6689fe0 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -5,15 +5,18 @@ import com.destroystokyo.paper.util.misc.PooledLinkedHashSets;
 import io.papermc.paper.configuration.GlobalConfiguration;
 import io.papermc.paper.util.CoordinateUtils;
 import io.papermc.paper.util.IntervalledCounter;
+import io.papermc.paper.util.MCUtil;
 import io.papermc.paper.util.TickThread;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.longs.LongSets;
-import it.unimi.dsi.fastutil.objects.*;
+import it.unimi.dsi.fastutil.objects.Reference2IntOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Reference2ObjectLinkedOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Reference2ObjectMap;
+import it.unimi.dsi.fastutil.objects.Reference2ObjectMaps;
 import net.minecraft.network.protocol.game.ClientboundSetChunkCacheCenterPacket;
 import net.minecraft.network.protocol.game.ClientboundSetChunkCacheRadiusPacket;
 import net.minecraft.network.protocol.game.ClientboundSetSimulationDistancePacket;
-import io.papermc.paper.util.MCUtil;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.*;
 import net.minecraft.util.Mth;
@@ -561,6 +564,7 @@ public final class PlayerChunkLoader {
             }
 
             if (!this.isChunkPlayerLoaded(queuedSend.chunkX, queuedSend.chunkZ)) {
+                this.chunkSendQueue.add(data);
                 continue;
             }
 
diff --git a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
index 387d07868301877dd7fca5d8dfd21e1331f4793e..e517d62df5352651a6f3c140f5ed63e4327bd530 100644
--- a/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
+++ b/src/main/java/io/papermc/paper/chunk/system/entity/EntityLookup.java
@@ -2,42 +2,33 @@ package io.papermc.paper.chunk.system.entity;
 
 import com.destroystokyo.paper.util.maplist.EntityList;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.chunk.system.ChunkSystem;
 import io.papermc.paper.util.CoordinateUtils;
 import io.papermc.paper.util.TickThread;
 import io.papermc.paper.util.WorldUtil;
 import io.papermc.paper.world.ChunkEntitySlices;
 import it.unimi.dsi.fastutil.ints.Int2ReferenceArrayMap;
 import it.unimi.dsi.fastutil.ints.Int2ReferenceMap;
-import it.unimi.dsi.fastutil.ints.Int2ReferenceOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectArrayMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMaps;
-import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.Object2ReferenceArrayMap;
 import it.unimi.dsi.fastutil.objects.Object2ReferenceMap;
-import it.unimi.dsi.fastutil.objects.Object2ReferenceOpenHashMap;
+import me.earthme.moka.util.NoSuchChunkEntitySlicesFoundException;
 import net.minecraft.core.BlockPos;
-import io.papermc.paper.chunk.system.ChunkSystem;
 import net.minecraft.server.level.ChunkHolder;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.util.AbortableIterationConsumer;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.EntityType;
-import net.minecraft.world.level.entity.EntityInLevelCallback;
-import net.minecraft.world.level.entity.EntityTypeTest;
-import net.minecraft.world.level.entity.LevelCallback;
-import net.minecraft.world.level.entity.LevelEntityGetter;
-import net.minecraft.world.level.entity.Visibility;
+import net.minecraft.world.level.entity.*;
 import net.minecraft.world.phys.AABB;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.NoSuchElementException;
-import java.util.UUID;
+
+import java.util.*;
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantLock;
 import java.util.concurrent.locks.StampedLock;
@@ -55,7 +46,6 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
     public final ServerLevel world;
 
     private final StampedLock entityByLock = new StampedLock();
-    private final Lock regionLoadLock = new ReentrantLock(true);
 
     protected final Long2ObjectMap<ChunkSlicesRegion> regions = Long2ObjectMaps.synchronize(new Long2ObjectArrayMap<>());
 
@@ -376,13 +366,7 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         if (!entity.isRemoved()) {
             throw new IllegalStateException("Only call Entity#setRemoved to remove an entity");
         }
-        ChunkEntitySlices slices;
-        this.regionLoadLock.lock();
-        try {
-            slices = this.getChunk(sectionX, sectionZ);
-        }finally {
-            this.regionLoadLock.unlock();
-        }
+        ChunkEntitySlices slices = this.getChunk(sectionX, sectionZ);
 
         // all entities should be in a chunk
         if (slices == null) {
@@ -426,17 +410,14 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         // ensure the old section is owned by this tick thread
         TickThread.ensureTickThread(this.world, entity.sectionX, entity.sectionZ, "Cannot move entity off-main");
 
-        ChunkEntitySlices old;
-
-        this.regionLoadLock.lock();
-        try {
-            old = this.getChunk(entity.sectionX, entity.sectionZ);
-        }finally {
-            this.regionLoadLock.unlock();
-        }
+        ChunkEntitySlices old = this.getChunk(entity.sectionX, entity.sectionZ);
 
         final ChunkEntitySlices slices = this.getOrCreateChunk(newSectionX, newSectionZ);
 
+        if (old == null){
+            throw new NoSuchChunkEntitySlicesFoundException(); //Moka
+        }
+
         if (!old.removeEntity(entity, entity.sectionY)) {
             LOGGER.warn("Could not remove entity " + entity + " from its old chunk section (" + entity.sectionX + "," + entity.sectionY + "," + entity.sectionZ + ") since it was not contained in the section");
         }
@@ -653,17 +634,12 @@ public final class EntityLookup implements LevelEntityGetter<Entity> {
         TickThread.ensureTickThread(this.world, chunkX, chunkZ, "Cannot load in entity section off-main");
         synchronized (this) {
             final ChunkEntitySlices curr = this.getChunk(chunkX, chunkZ);
-            this.regionLoadLock.lock();
-            try {
-                if (curr != null) {
-                    this.removeChunk(chunkX, chunkZ);
-                    curr.mergeInto(slices);
-                    this.addChunk(chunkX, chunkZ, slices);
-                } else {
-                    this.addChunk(chunkX, chunkZ, slices);
-                }
-            } finally {
-                this.regionLoadLock.unlock();
+            if (curr != null) {
+                this.removeChunk(chunkX, chunkZ);
+                curr.mergeInto(slices);
+                this.addChunk(chunkX, chunkZ, slices);
+            } else {
+                this.addChunk(chunkX, chunkZ, slices);
             }
         }
     }
diff --git a/src/main/java/io/papermc/paper/plugin/provider/source/SparkProviderSource.java b/src/main/java/io/papermc/paper/plugin/provider/source/SparkProviderSource.java
index e3b2ac266cd2e75ca760c8f532dd9e79ef384e9b..ef9ad9f713d82b0ab1ec1d34c9030806557cb10c 100644
--- a/src/main/java/io/papermc/paper/plugin/provider/source/SparkProviderSource.java
+++ b/src/main/java/io/papermc/paper/plugin/provider/source/SparkProviderSource.java
@@ -1,6 +1,6 @@
 package io.papermc.paper.plugin.provider.source;
 
-import co.earthme.hearse.HearseConfig;
+import me.earthme.moka.MokaConfig;
 import com.mojang.logging.LogUtils;
 import io.papermc.paper.plugin.entrypoint.Entrypoint;
 import io.papermc.paper.plugin.entrypoint.EntrypointHandler;
@@ -32,7 +32,7 @@ public class SparkProviderSource extends FileProviderSource {
     @Override
     public void registerProviders(EntrypointHandler entrypointHandler, Path context) throws Exception {
         if (!Boolean.getBoolean("Purpur.IReallyDontWantSpark")) {
-            if (HearseConfig.getBoolean("purpurmisc.auto-download-spark", true)) {
+            if (MokaConfig.getBoolean("purpurmisc.auto-download-spark", true)) {
                 try {
                     File file = context.toFile();
                     file.getParentFile().mkdirs();
diff --git a/src/main/java/io/papermc/paper/util/CachedLists.java b/src/main/java/io/papermc/paper/util/CachedLists.java
index f543462240e744e3424d302eb62be46c70ef9377..82617ff411a73e97cc65807a5858a37bbacb87c7 100644
--- a/src/main/java/io/papermc/paper/util/CachedLists.java
+++ b/src/main/java/io/papermc/paper/util/CachedLists.java
@@ -7,13 +7,13 @@ import java.util.List;
 
 public final class CachedLists {
     public static List<AABB> getTempCollisionList() {
-        return Lists.newCopyOnWriteArrayList();
+        return Lists.newArrayList();
     }
 
     public static void returnTempCollisionList(List<AABB> list) {}
 
     public static List<Entity> getTempGetEntitiesList() {
-        return Lists.newCopyOnWriteArrayList();
+        return Lists.newArrayList();
     }
 
     public static void returnTempGetEntitiesList(List<Entity> list) {}
diff --git a/src/main/java/io/papermc/paper/util/TickThread.java b/src/main/java/io/papermc/paper/util/TickThread.java
index ea277170975f59561775ad9b63467a7c9abdbbe3..abd537da9364aba4bf104fc42a01188cf84e7e14 100644
--- a/src/main/java/io/papermc/paper/util/TickThread.java
+++ b/src/main/java/io/papermc/paper/util/TickThread.java
@@ -1,10 +1,10 @@
 package io.papermc.paper.util;
 
-import co.earthme.hearse.concurrent.thread.Worker;
+import me.earthme.moka.concurrent.thread.Worker;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.Entity;
-import org.bukkit.Bukkit;
+
 import java.util.concurrent.atomic.AtomicInteger;
 
 public class TickThread extends Thread {
diff --git a/src/main/java/co/earthme/hearse/Hearse.java b/src/main/java/me/earthme/moka/Moka.java
similarity index 56%
rename from src/main/java/co/earthme/hearse/Hearse.java
rename to src/main/java/me/earthme/moka/Moka.java
index 692fef51b2f15dd1ddc28773a381b9da3b42725e..e520f342623fb15158615127601f1c2d28cbedaa 100644
--- a/src/main/java/co/earthme/hearse/Hearse.java
+++ b/src/main/java/me/earthme/moka/Moka.java
@@ -1,23 +1,23 @@
-package co.earthme.hearse;
+package me.earthme.moka;
 
-import co.earthme.hearse.commands.EntityCountCommand;
-import co.earthme.hearse.commands.WorkerCommand;
-import co.earthme.hearse.server.ServerEntityTickHook;
-import co.earthme.hearse.workers.WorkerThreadPoolManager;
+import me.earthme.moka.commands.EntityCountCommand;
+import me.earthme.moka.commands.WorkerCommand;
+import me.earthme.moka.server.ServerEntityTickHook;
+import me.earthme.moka.workers.WorkerThreadPoolManager;
 import net.minecraft.server.MinecraftServer;
 
-public class Hearse {
+public class Moka {
     private static final WorkerThreadPoolManager workerManager = new WorkerThreadPoolManager();
 
     public static void initAll(){
-        HearseConfig.init();
+        MokaConfig.init();
         ServerEntityTickHook.init();
-        MinecraftServer.getServer().server.getCommandMap().register("workers","hearse",new WorkerCommand());
-        MinecraftServer.getServer().server.getCommandMap().register("entitycount","hearse",new EntityCountCommand());
+        MinecraftServer.getServer().server.getCommandMap().register("workers","moka",new WorkerCommand());
+        MinecraftServer.getServer().server.getCommandMap().register("entitycount","moka",new EntityCountCommand());
     }
 
     public static void onServerStop(){
-        HearseConfig.save();
+        MokaConfig.save();
         workerManager.shutdownAllNow();
     }
 
diff --git a/src/main/java/co/earthme/hearse/HearseConfig.java b/src/main/java/me/earthme/moka/MokaConfig.java
similarity index 91%
rename from src/main/java/co/earthme/hearse/HearseConfig.java
rename to src/main/java/me/earthme/moka/MokaConfig.java
index 73b5e76660b5162a7a0b327ddc7dcc3295b86699..e33f56a8430a8db6fe81ba12c6777b6a1ef61a4b 100644
--- a/src/main/java/co/earthme/hearse/HearseConfig.java
+++ b/src/main/java/me/earthme/moka/MokaConfig.java
@@ -1,13 +1,14 @@
-package co.earthme.hearse;
+package me.earthme.moka;
 
 import org.bukkit.configuration.InvalidConfigurationException;
 import org.bukkit.configuration.file.YamlConfiguration;
+
 import java.io.File;
 import java.io.IOException;
 
-public class HearseConfig {
+public class MokaConfig {
     private static final YamlConfiguration configEntry = new YamlConfiguration();
-    private static final File CONFIG_FILE = new File("hearse.yml");
+    private static final File CONFIG_FILE = new File("moka.yml");
 
     public static void init(){
         try {
diff --git a/src/main/java/co/earthme/hearse/commands/EntityCountCommand.java b/src/main/java/me/earthme/moka/commands/EntityCountCommand.java
similarity index 97%
rename from src/main/java/co/earthme/hearse/commands/EntityCountCommand.java
rename to src/main/java/me/earthme/moka/commands/EntityCountCommand.java
index de759c808040058062078130b527e78215216ebb..c5bcbb1758fd677c4a9327eff3cc7e8e3c689326 100644
--- a/src/main/java/co/earthme/hearse/commands/EntityCountCommand.java
+++ b/src/main/java/me/earthme/moka/commands/EntityCountCommand.java
@@ -1,4 +1,4 @@
-package co.earthme.hearse.commands;
+package me.earthme.moka.commands;
 
 import com.google.common.collect.Maps;
 import net.minecraft.server.MinecraftServer;
@@ -8,6 +8,7 @@ import org.bukkit.ChatColor;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandSender;
 import org.jetbrains.annotations.NotNull;
+
 import java.util.Map;
 
 public class EntityCountCommand extends Command {
diff --git a/src/main/java/co/earthme/hearse/commands/WorkerCommand.java b/src/main/java/me/earthme/moka/commands/WorkerCommand.java
similarity index 53%
rename from src/main/java/co/earthme/hearse/commands/WorkerCommand.java
rename to src/main/java/me/earthme/moka/commands/WorkerCommand.java
index 1a4a6869a7278beadd97af006f4b5fae578b83ed..371fbf73698e7079ce4cab1a940a2992250638bd 100644
--- a/src/main/java/co/earthme/hearse/commands/WorkerCommand.java
+++ b/src/main/java/me/earthme/moka/commands/WorkerCommand.java
@@ -1,11 +1,12 @@
-package co.earthme.hearse.commands;
+package me.earthme.moka.commands;
 
-import co.earthme.hearse.Hearse;
-import co.earthme.hearse.concurrent.WorkerThreadPoolExecutor;
+import me.earthme.moka.Moka;
+import me.earthme.moka.concurrent.WorkerThreadPool;
 import org.bukkit.ChatColor;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandSender;
 import org.jetbrains.annotations.NotNull;
+
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
@@ -27,7 +28,7 @@ public class WorkerCommand extends Command {
             ret.add("forceStop");
         }
         if (args.length == 2){
-            for (Map.Entry<String, WorkerThreadPoolExecutor> entry : Hearse.getWorkerManager().getManagedWorkers().entrySet()){
+            for (Map.Entry<String, WorkerThreadPool> entry : Moka.getWorkerManager().getManagedWorkers().entrySet()){
                 ret.add(entry.getKey());
             }
         }
@@ -39,31 +40,18 @@ public class WorkerCommand extends Command {
         if (args.length >= 2){
             final String action = args[0];
             final String workerName = args[1];
-            final WorkerThreadPoolExecutor searchedWorker = Hearse.getWorkerManager().getTargetWorker(workerName);
+            final WorkerThreadPool searchedWorker = Moka.getWorkerManager().getTargetWorker(workerName);
             if (searchedWorker == null){
                 sender.sendMessage(ChatColor.RED+"Target worker not found!");
                 return true;
             }
-            switch (action){
-                case "status":
-                    sender.sendMessage(ChatColor.GREEN+"Worker: "+workerName+" Status:"+ searchedWorker);
-                    break;
-                case "setThreadCount":
-                    if (args.length == 3){
-                        try {
-                            searchedWorker.setCorePoolSize(Integer.parseInt(args[2]));
-                            sender.sendMessage(ChatColor.GREEN+"Finished!");
-                        }catch (NumberFormatException e){
-                            sender.sendMessage(ChatColor.RED+"Please supply an integer!");
-                        }
-                    }else{
-                        sender.sendMessage(ChatColor.RED+"Please supply an integer!");
-                    }
-                    break;
-                case "forceStop":
-                    searchedWorker.shutdownNow();
-                    sender.sendMessage(ChatColor.YELLOW+"Worker "+workerName+" has been stopped!");
-                    break;
+            switch (action) {
+                case "status" ->
+                        sender.sendMessage(ChatColor.GREEN + "Worker: " + workerName + " Status:" + searchedWorker);
+                case "forceStop" -> {
+                    searchedWorker.terminateNow();
+                    sender.sendMessage(ChatColor.YELLOW + "Worker " + workerName + " has been stopped!");
+                }
             }
             return true;
         }
diff --git a/src/main/java/me/earthme/moka/concurrent/WorkStealingThreadPool.java b/src/main/java/me/earthme/moka/concurrent/WorkStealingThreadPool.java
new file mode 100644
index 0000000000000000000000000000000000000000..dff9a13ed7f4ecf59f9bbaa25d18835345cfab1d
--- /dev/null
+++ b/src/main/java/me/earthme/moka/concurrent/WorkStealingThreadPool.java
@@ -0,0 +1,230 @@
+package me.earthme.moka.concurrent;
+
+import com.google.common.collect.Lists;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collection;
+import java.util.Deque;
+import java.util.List;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.Future;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.LockSupport;
+
+public class WorkStealingThreadPool implements WorkerThreadPool{
+    private static final Logger logger = LogManager.getLogger();
+
+    private WorkerThread[] workerThreads = null;
+    private final ExceptionHandler exceptionHandler;
+    private volatile boolean creatingThreads = false;
+    private final WorkerThreadFactory factory;
+    private int lastPostedPos = 0;
+
+    public WorkStealingThreadPool(int nThreads, ExceptionHandler exceptionHandler, WorkerThreadFactory factory) {
+        this.exceptionHandler = exceptionHandler;
+        this.factory = factory;
+        this.runWorkers(nThreads);
+    }
+
+    public WorkStealingThreadPool(int nThreads,WorkerThreadFactory factory){
+        this(nThreads,(exception,thread)->{
+            logger.warn("Worker {} has a exception:{}",thread.getName(),exception);
+            exception.printStackTrace();
+        },factory);
+    }
+
+    private void runWorkers(int threadCount) {
+        this.creatingThreads = true;
+        try {
+            this.workerThreads = new WorkerThread[threadCount];
+            for (int i = 0; i < threadCount; i++) {
+                final WorkerThread workerThread = new WorkerThread();
+                this.workerThreads[i] = workerThread;
+                workerThread.start();
+            }
+        }finally {
+            this.creatingThreads = false;
+        }
+    }
+
+    @Override
+    public void postTask(@NotNull Runnable task) {
+        int workerIndex;
+        if (this.lastPostedPos + 1 >= this.workerThreads.length) {
+            this.lastPostedPos = 0;
+        }
+        workerIndex = this.lastPostedPos++;
+
+        final WorkerThread workerThread = this.workerThreads[workerIndex];
+        workerThread.postRunnable(task);
+    }
+
+    @Override
+    public Future<?> postTask(Callable<?> task) {
+        final FutureTask<?> futureTask = new FutureTask<>(task);
+        this.postTask(futureTask);
+        return futureTask;
+    }
+
+
+    @Override
+    public void terminate() {
+        for (WorkerThread workerThread : this.workerThreads) {
+            workerThread.sendStop();
+        }
+
+        for (WorkerThread workerThread : this.workerThreads){
+            workerThread.awaitTerminate();
+        }
+
+        this.workerThreads = null;
+    }
+
+    @Override
+    public void terminateNow() {
+        this.dropAllTasks();
+        this.terminate();
+    }
+
+    @Override
+    public Collection<? extends Runnable> dropAllTasks() {
+        final List<Runnable> taskList = Lists.newArrayList();
+
+        for (WorkerThread workerThread : this.workerThreads){
+            taskList.addAll(workerThread.dropAllTask());
+        }
+
+        return taskList;
+    }
+
+    private interface ExceptionHandler{
+        void handle(Exception exception,Thread thread);
+    }
+
+    private class WorkerThread implements Runnable {
+        private final Deque<Runnable> tasks = new ConcurrentLinkedDeque<>();
+        private final AtomicBoolean runningTask = new AtomicBoolean();
+        private final Thread worker = WorkStealingThreadPool.this.factory.getNewThread(this);
+
+        private volatile boolean shouldRun = false;
+        private volatile boolean running = false;
+        private volatile boolean block = false;
+
+
+        @NotNull
+        protected Collection<Runnable> dropAllTask(){
+            this.block = true;
+            try {
+                final List<Runnable> taskList = Lists.newArrayList();
+                Runnable task;
+                while ((task = this.tasks.poll())!=null){
+                    taskList.add(task);
+                }
+                return taskList;
+            }finally {
+                this.block = false;
+            }
+        }
+
+        public void postRunnable(@NotNull Runnable task) {
+            this.tasks.offer(task);
+        }
+
+        public void sendStop() {
+            this.shouldRun = false;
+            LockSupport.unpark(this.worker);
+        }
+
+        public void awaitTerminate() {
+            while (this.running) {
+                LockSupport.parkNanos(100000);
+            }
+        }
+
+        public void awaitTask() {
+            while (this.runningTask.get()) {
+                LockSupport.parkNanos(100000);
+            }
+        }
+
+        @Override
+        public void run() {
+            Runnable curTask;
+            Runnable stole;
+            while (this.shouldRun || !this.tasks.isEmpty()) {
+                if (!this.block){
+                    if ((curTask = this.pollTask(false)) != null) {
+                        this.runningTask.set(true);
+                        try {
+                            curTask.run();
+                        } catch (Exception e) {
+                            WorkStealingThreadPool.this.exceptionHandler.handle(e,this.worker);
+                        } finally {
+                            this.runningTask.set(false);
+                        }
+                        continue;
+                    }
+
+                    if ((stole = this.steal()) != null) {
+                        try {
+                            stole.run();
+                        } catch (Exception e) {
+                            WorkStealingThreadPool.this.exceptionHandler.handle(e,this.worker);
+                        }
+                        continue;
+                    }
+                }
+
+                LockSupport.parkNanos("IDLE", 1000000);
+            }
+            this.running = false;
+        }
+
+        public void start() {
+            this.running = true;
+            this.shouldRun = true;
+            this.worker.start();
+        }
+
+        @Nullable
+        protected Runnable steal() {
+            if (WorkStealingThreadPool.this.creatingThreads){
+                return null;
+            }
+
+            for (WorkerThread workerThread : WorkStealingThreadPool.this.workerThreads) {
+                if (workerThread.equals(this)) {
+                    continue;
+                }
+
+                if ((workerThread.isCurrentThreadRunningTask() || workerThread.isBlocking()) && workerThread.getQueuedTaskCount() > 0) {
+                    return workerThread.pollTask(true);
+                }
+            }
+            return null;
+        }
+
+        protected boolean isBlocking(){
+            return this.block;
+        }
+
+
+        protected int getQueuedTaskCount() {
+            return this.tasks.size();
+        }
+
+        protected boolean isCurrentThreadRunningTask() {
+            return this.runningTask.get();
+        }
+
+        @Nullable
+        protected Runnable pollTask(boolean tail) {
+            return tail ? this.tasks.pollLast() : this.tasks.pollFirst();
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/earthme/moka/concurrent/WorkerThreadFactory.java b/src/main/java/me/earthme/moka/concurrent/WorkerThreadFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..5ca083add5323cd03d5f2892fbc5ba7d04b7e1ac
--- /dev/null
+++ b/src/main/java/me/earthme/moka/concurrent/WorkerThreadFactory.java
@@ -0,0 +1,7 @@
+package me.earthme.moka.concurrent;
+
+import me.earthme.moka.concurrent.thread.WorkerThread;
+
+public interface WorkerThreadFactory {
+    WorkerThread getNewThread(Runnable task);
+}
diff --git a/src/main/java/me/earthme/moka/concurrent/WorkerThreadPool.java b/src/main/java/me/earthme/moka/concurrent/WorkerThreadPool.java
new file mode 100644
index 0000000000000000000000000000000000000000..52f751438cd5d063ef25367d17df4a8577446e95
--- /dev/null
+++ b/src/main/java/me/earthme/moka/concurrent/WorkerThreadPool.java
@@ -0,0 +1,17 @@
+package me.earthme.moka.concurrent;
+
+import java.util.Collection;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Future;
+
+public interface WorkerThreadPool{
+    void terminate();
+
+    void terminateNow();
+
+    Collection<? extends Runnable> dropAllTasks();
+
+    void postTask(Runnable task);
+
+    Future<?> postTask(Callable<?> task);
+}
diff --git a/src/main/java/co/earthme/hearse/concurrent/WorkerThreadPoolExecutor.java b/src/main/java/me/earthme/moka/concurrent/WorkerThreadPoolExecutor.java
similarity index 78%
rename from src/main/java/co/earthme/hearse/concurrent/WorkerThreadPoolExecutor.java
rename to src/main/java/me/earthme/moka/concurrent/WorkerThreadPoolExecutor.java
index 7e010bf23c9fc26284212a4388172f5d7d5a4b99..f14fd670022a7a7d3671a43af5a2e08ef2b28742 100644
--- a/src/main/java/co/earthme/hearse/concurrent/WorkerThreadPoolExecutor.java
+++ b/src/main/java/me/earthme/moka/concurrent/WorkerThreadPoolExecutor.java
@@ -1,12 +1,15 @@
-package co.earthme.hearse.concurrent;
+package me.earthme.moka.concurrent;
 
+import com.google.common.collect.Lists;
 import org.jetbrains.annotations.NotNull;
 
+import java.util.Collection;
+import java.util.List;
 import java.util.Queue;
 import java.util.concurrent.*;
 import java.util.concurrent.locks.LockSupport;
 
-public class WorkerThreadPoolExecutor extends ThreadPoolExecutor {
+public class WorkerThreadPoolExecutor extends ThreadPoolExecutor implements WorkerThreadPool{
     private final Queue<TaskEntry> taskEntries = new ConcurrentLinkedQueue<>();
 
     public WorkerThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, @NotNull TimeUnit unit, @NotNull BlockingQueue<Runnable> workQueue, @NotNull WorkerThreadFactory workerThreadFactory) {
@@ -40,6 +43,33 @@ public class WorkerThreadPoolExecutor extends ThreadPoolExecutor {
         }
     }
 
+    @Override
+    public void terminate() {
+        this.shutdown();
+    }
+
+    @Override
+    public void terminateNow() {
+        this.shutdownNow();
+    }
+
+    @Override
+    public Collection<? extends Runnable> dropAllTasks() {
+        final List<Runnable> tasks = Lists.newArrayList();
+        this.getQueue().drainTo(tasks);
+        return tasks;
+    }
+
+    @Override
+    public void postTask(Runnable task) {
+        this.execute(task);
+    }
+
+    @Override
+    public Future<?> postTask(Callable<?> task) {
+        return this.submit(task);
+    }
+
     private static class TaskEntry implements Runnable{
         private final Runnable mainTask;
         private final Runnable subTask;
diff --git a/src/main/java/co/earthme/hearse/concurrent/thread/Worker.java b/src/main/java/me/earthme/moka/concurrent/thread/Worker.java
similarity index 73%
rename from src/main/java/co/earthme/hearse/concurrent/thread/Worker.java
rename to src/main/java/me/earthme/moka/concurrent/thread/Worker.java
index e7a944bd515af644bad37a23e012a5a1997e110d..9c51edbaaa5f3b921eb55b853aabb3c4c4f0be10 100644
--- a/src/main/java/co/earthme/hearse/concurrent/thread/Worker.java
+++ b/src/main/java/me/earthme/moka/concurrent/thread/Worker.java
@@ -1,4 +1,4 @@
-package co.earthme.hearse.concurrent.thread;
+package me.earthme.moka.concurrent.thread;
 
 public interface Worker {
     static boolean isWorker(){
diff --git a/src/main/java/co/earthme/hearse/concurrent/thread/WorkerForkJoinThread.java b/src/main/java/me/earthme/moka/concurrent/thread/WorkerForkJoinThread.java
similarity index 85%
rename from src/main/java/co/earthme/hearse/concurrent/thread/WorkerForkJoinThread.java
rename to src/main/java/me/earthme/moka/concurrent/thread/WorkerForkJoinThread.java
index 6a2fb0643b6fc5921b24674940c2c3b92b9e4e88..f4957fec5441eca5fe29efb631205941f47b4bb9 100644
--- a/src/main/java/co/earthme/hearse/concurrent/thread/WorkerForkJoinThread.java
+++ b/src/main/java/me/earthme/moka/concurrent/thread/WorkerForkJoinThread.java
@@ -1,4 +1,4 @@
-package co.earthme.hearse.concurrent.thread;
+package me.earthme.moka.concurrent.thread;
 
 import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.ForkJoinWorkerThread;
diff --git a/src/main/java/co/earthme/hearse/concurrent/thread/WorkerThread.java b/src/main/java/me/earthme/moka/concurrent/thread/WorkerThread.java
similarity index 85%
rename from src/main/java/co/earthme/hearse/concurrent/thread/WorkerThread.java
rename to src/main/java/me/earthme/moka/concurrent/thread/WorkerThread.java
index f27bfd7ab3ce10e6c318de0c6376a80fa9014d2a..ccfe800273bf2ce2cea6df50ad1a510cacd99f97 100644
--- a/src/main/java/co/earthme/hearse/concurrent/thread/WorkerThread.java
+++ b/src/main/java/me/earthme/moka/concurrent/thread/WorkerThread.java
@@ -1,4 +1,4 @@
-package co.earthme.hearse.concurrent.thread;
+package me.earthme.moka.concurrent.thread;
 
 import io.papermc.paper.util.TickThread;
 
diff --git a/src/main/java/co/earthme/hearse/concurrent/threadfactory/DefaultWorkerFactory.java b/src/main/java/me/earthme/moka/concurrent/threadfactory/DefaultWorkerFactory.java
similarity index 89%
rename from src/main/java/co/earthme/hearse/concurrent/threadfactory/DefaultWorkerFactory.java
rename to src/main/java/me/earthme/moka/concurrent/threadfactory/DefaultWorkerFactory.java
index b88b4f2d3df7303252a3c02824be3514c2618673..817541d061a592216652a69b3aa6aa7927800344 100644
--- a/src/main/java/co/earthme/hearse/concurrent/threadfactory/DefaultWorkerFactory.java
+++ b/src/main/java/me/earthme/moka/concurrent/threadfactory/DefaultWorkerFactory.java
@@ -1,10 +1,11 @@
-package co.earthme.hearse.concurrent.threadfactory;
+package me.earthme.moka.concurrent.threadfactory;
 
-import co.earthme.hearse.concurrent.thread.WorkerThread;
-import co.earthme.hearse.concurrent.WorkerThreadFactory;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectLists;
+import me.earthme.moka.concurrent.WorkerThreadFactory;
+import me.earthme.moka.concurrent.thread.WorkerThread;
 import net.minecraft.server.MinecraftServer;
+
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
 
diff --git a/src/main/java/co/earthme/hearse/server/ServerEntityTickHook.java b/src/main/java/me/earthme/moka/server/ServerEntityTickHook.java
similarity index 75%
rename from src/main/java/co/earthme/hearse/server/ServerEntityTickHook.java
rename to src/main/java/me/earthme/moka/server/ServerEntityTickHook.java
index 1896d163104236a618b659977045b18288f403c8..a5e0e3f5d40318a2f14ddaee055b7f42a3639e22 100644
--- a/src/main/java/co/earthme/hearse/server/ServerEntityTickHook.java
+++ b/src/main/java/me/earthme/moka/server/ServerEntityTickHook.java
@@ -1,9 +1,11 @@
-package co.earthme.hearse.server;
+package me.earthme.moka.server;
 
-import co.earthme.hearse.HearseConfig;
-import co.earthme.hearse.concurrent.WorkStealingThreadPool;
-import co.earthme.hearse.concurrent.WorkerThreadFactory;
-import co.earthme.hearse.concurrent.threadfactory.DefaultWorkerFactory;
+import me.earthme.moka.Moka;
+import me.earthme.moka.MokaConfig;
+import me.earthme.moka.concurrent.WorkStealingThreadPool;
+import me.earthme.moka.concurrent.WorkerThreadFactory;
+import me.earthme.moka.concurrent.threadfactory.DefaultWorkerFactory;
+import me.earthme.moka.util.NoSuchChunkEntitySlicesFoundException;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.Entity;
@@ -31,14 +33,15 @@ public class ServerEntityTickHook {
     }
 
     public static void init(){
-        asyncEntityEnabled = HearseConfig.getBoolean("optimizations.enable-parallel-entity",asyncEntityEnabled);
-        awaitEntityTasks = HearseConfig.getBoolean("optimizations.await-parallel-entity-tasks",awaitEntityTasks);
+        asyncEntityEnabled = MokaConfig.getBoolean("optimizations.enable-parallel-entity",asyncEntityEnabled);
+        awaitEntityTasks = MokaConfig.getBoolean("optimizations.await-parallel-entity-tasks",awaitEntityTasks);
         if (asyncEntityEnabled){
-            final int workerCount = HearseConfig.getInt("workers.async-entity-worker-count",Runtime.getRuntime().availableProcessors());
+            final int workerCount = MokaConfig.getInt("workers.async-entity-worker-count",Runtime.getRuntime().availableProcessors());
             worker = new WorkStealingThreadPool(
                     workerCount,
                     defFactory
             );
+            Moka.getWorkerManager().addWorker("entity",worker);
         }
     }
 
@@ -59,7 +62,9 @@ public class ServerEntityTickHook {
                     }
                     try {
                         level.tickNonPassenger(entity);
-                    } catch (Throwable throwable) {
+                    }catch (NoSuchChunkEntitySlicesFoundException e){
+                        //Do nothing here.
+                    }catch (Throwable throwable) {
                         if (throwable instanceof ThreadDeath) throw throwable;
                         level.getCraftServer().getPluginManager().callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new com.destroystokyo.paper.exception.ServerInternalException(throwable.getMessage(), throwable)));
                         throwable.printStackTrace();
diff --git a/src/main/java/co/earthme/hearse/server/ServerLevelTickHook.java b/src/main/java/me/earthme/moka/server/ServerLevelTickHook.java
similarity index 83%
rename from src/main/java/co/earthme/hearse/server/ServerLevelTickHook.java
rename to src/main/java/me/earthme/moka/server/ServerLevelTickHook.java
index 4c85bf8e4705a781a55a048f0b0541f0d32e2f07..aed00e0ca091affd160a385c43e8c2a08c852c29 100644
--- a/src/main/java/co/earthme/hearse/server/ServerLevelTickHook.java
+++ b/src/main/java/me/earthme/moka/server/ServerLevelTickHook.java
@@ -1,11 +1,9 @@
-package co.earthme.hearse.server;
+package me.earthme.moka.server;
 
-import co.earthme.hearse.Hearse;
-import co.earthme.hearse.HearseConfig;
-import co.earthme.hearse.concurrent.WorkerThreadPoolExecutor;
-import co.earthme.hearse.concurrent.threadfactory.DefaultWorkerFactory;
-import co.earthme.hearse.util.ArrayListBlockingQueue;
-import io.netty.handler.codec.serialization.ObjectEncoder;
+import me.earthme.moka.Moka;
+import me.earthme.moka.MokaConfig;
+import me.earthme.moka.concurrent.WorkerThreadPoolExecutor;
+import me.earthme.moka.concurrent.threadfactory.DefaultWorkerFactory;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
 import org.apache.logging.log4j.LogManager;
@@ -24,7 +22,7 @@ public class ServerLevelTickHook {
     private static final Logger logger = LogManager.getLogger();
 
     public static void initWorker(){
-        boolean enabledParaWorld = HearseConfig.getBoolean("optimizations.enableparallelworldtick", true);
+        boolean enabledParaWorld = MokaConfig.getBoolean("optimizations.enableparallelworldtick", true);
         if (enabledParaWorld){
             worker = new WorkerThreadPoolExecutor(
                     MinecraftServer.getServer().levels.size(),
@@ -36,7 +34,7 @@ public class ServerLevelTickHook {
             );
             worker.allowCoreThreadTimeOut(true);
             worker.prestartAllCoreThreads();
-            Hearse.getWorkerManager().addWorker("world",worker);
+            Moka.getWorkerManager().addWorker("world",worker);
             for (Thread worker : workerFactory.getCreatedThreads()){
                 logger.warn("World worker name:{}.This can help you to slove the lag problems when you using parallel world ticking",worker.getName());
             }
diff --git a/src/main/java/co/earthme/hearse/util/ArrayListBlockingQueue.java b/src/main/java/me/earthme/moka/util/ArrayListBlockingQueue.java
similarity index 97%
rename from src/main/java/co/earthme/hearse/util/ArrayListBlockingQueue.java
rename to src/main/java/me/earthme/moka/util/ArrayListBlockingQueue.java
index ec63191dca67c51f387ede9796a039210c8c3f99..07c556c830cd419ceeb90ac4f3c6b370e9158275 100644
--- a/src/main/java/co/earthme/hearse/util/ArrayListBlockingQueue.java
+++ b/src/main/java/me/earthme/moka/util/ArrayListBlockingQueue.java
@@ -1,10 +1,11 @@
-package co.earthme.hearse.util;
+package me.earthme.moka.util;
 
 import org.jetbrains.annotations.NotNull;
 
 import java.util.*;
-import java.util.concurrent.*;
-import java.util.concurrent.locks.*;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.locks.StampedLock;
 
 public class ArrayListBlockingQueue<T> implements BlockingQueue<T> {
     private final List<T> internalList = new ArrayList<>();
diff --git a/src/main/java/co/earthme/hearse/util/EntityPositionCache.java b/src/main/java/me/earthme/moka/util/EntityPositionCache.java
similarity index 97%
rename from src/main/java/co/earthme/hearse/util/EntityPositionCache.java
rename to src/main/java/me/earthme/moka/util/EntityPositionCache.java
index 6f34233901cf1943694224ab393dea5548cb8e5b..45e23226d2e804ed68f5551415e456bb6576b26a 100644
--- a/src/main/java/co/earthme/hearse/util/EntityPositionCache.java
+++ b/src/main/java/me/earthme/moka/util/EntityPositionCache.java
@@ -1,4 +1,4 @@
-package co.earthme.hearse.util;
+package me.earthme.moka.util;
 
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.LivingEntity;
diff --git a/src/main/java/me/earthme/moka/util/NoSuchChunkEntitySlicesFoundException.java b/src/main/java/me/earthme/moka/util/NoSuchChunkEntitySlicesFoundException.java
new file mode 100644
index 0000000000000000000000000000000000000000..2c43510ca1173b863976c4501f5565d4dbbb0961
--- /dev/null
+++ b/src/main/java/me/earthme/moka/util/NoSuchChunkEntitySlicesFoundException.java
@@ -0,0 +1,4 @@
+package me.earthme.moka.util;
+
+public class NoSuchChunkEntitySlicesFoundException extends RuntimeException{
+}
diff --git a/src/main/java/me/earthme/moka/workers/WorkerThreadPoolManager.java b/src/main/java/me/earthme/moka/workers/WorkerThreadPoolManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..455a1eb92ddd5a301d27395518d4998269c3ffab
--- /dev/null
+++ b/src/main/java/me/earthme/moka/workers/WorkerThreadPoolManager.java
@@ -0,0 +1,43 @@
+package me.earthme.moka.workers;
+
+import com.google.common.collect.Maps;
+import me.earthme.moka.concurrent.WorkerThreadPool;
+
+import java.util.List;
+import java.util.Map;
+
+public class WorkerThreadPoolManager {
+    private final Map<String, WorkerThreadPool> managedWorkers = Maps.newHashMap();
+
+    public void addWorker(String bound,WorkerThreadPool worker){
+        this.managedWorkers.put(bound,worker);
+    }
+
+    public void shutdownAll() throws InterruptedException {
+        for (WorkerThreadPool worker : this.managedWorkers.values()){
+            worker.terminateNow();
+        }
+        this.managedWorkers.clear();
+    }
+
+    @Deprecated
+    public Map<String, WorkerThreadPool> getManagedWorkers() {
+        return Maps.newHashMap(this.managedWorkers);
+    }
+
+    @Deprecated
+    public WorkerThreadPool getTargetWorker(String bound){
+        return this.managedWorkers.get(bound);
+    }
+
+    public Map<String,List<Runnable>> shutdownAllNow(){
+        final Map<String,List<Runnable>> ret = Maps.newHashMap();
+        for (Map.Entry<String,WorkerThreadPool> entry : this.managedWorkers.entrySet()){
+            final String workerName = entry.getKey();
+            final WorkerThreadPool worker = entry.getValue();
+            ret.put(workerName, (List<Runnable>) worker.dropAllTasks());
+            worker.terminateNow();
+        }
+        return ret;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 324c2684490aac1afe2de877e20bd284e1e1e950..9d683194ca320f1691e001b024c64e651b4c6606 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -192,9 +192,9 @@ import org.bukkit.event.player.AsyncPlayerChatPreviewEvent;
 import org.bukkit.event.server.ServerLoadEvent;
 // CraftBukkit end
 
-import co.earthme.hearse.Hearse;
-import co.earthme.hearse.server.ServerEntityTickHook;
-import co.earthme.hearse.server.ServerLevelTickHook;
+import me.earthme.moka.Moka;
+import me.earthme.moka.server.ServerEntityTickHook;
+import me.earthme.moka.server.ServerLevelTickHook;
 
 import co.aikar.timings.MinecraftTimings; // Paper
 
@@ -931,7 +931,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
         if (!hasLoggedStop && isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread("Server stopped"); // Paper
         // Paper start - kill main thread, and kill it hard
-        Hearse.onServerStop();//Hearse
+        Moka.onServerStop();//Hearse
         shutdownThread = Thread.currentThread();
         org.spigotmc.WatchdogThread.doStop(); // Paper
         if (!isSameThread()) {
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 3749cab6e608bfc70eb0bc345368bbc28b5d5a44..7d46a2c52854a7ba52ce1ed1f4ee74043f271767 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -1,21 +1,16 @@
 package net.minecraft.server.dedicated;
 
-import co.earthme.hearse.Hearse;
-import com.google.common.collect.Lists;
+import me.earthme.moka.Moka;
 import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
-import java.io.BufferedReader;
+
 import java.io.BufferedWriter;
 import java.io.IOException;
-import java.io.InputStreamReader;
 import java.net.InetAddress;
 import java.net.Proxy;
-import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.Collections;
-import java.util.List;
 import java.util.Locale;
 import java.util.Optional;
 import java.util.function.BooleanSupplier;
@@ -59,7 +54,6 @@ import org.apache.logging.log4j.Level;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.io.IoBuilder;
 import org.bukkit.command.CommandSender;
-import co.aikar.timings.MinecraftTimings; // Paper
 import org.bukkit.event.server.ServerCommandEvent;
 import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.server.RemoteServerCommandEvent;
@@ -235,7 +229,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         gg.pufferfish.pufferfish.PufferfishConfig.load(); // Pufferfish
         gg.pufferfish.pufferfish.PufferfishCommand.init(); // Pufferfish
 
-        Hearse.initAll(); //Hearse
+        Moka.initAll(); //Hearse
 
         this.setPvpAllowed(dedicatedserverproperties.pvp);
         this.setFlightAllowed(dedicatedserverproperties.allowFlight);
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 1d0c84ac74c27b10a9b1bd74b6e0c3eeeca26fb1..3bdda710602219c104e2051f1218dca12da0bf74 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -1,10 +1,10 @@
 package net.minecraft.server.level;
 
 import co.aikar.timings.Timing; // Paper
-import co.earthme.hearse.Hearse;
-import co.earthme.hearse.HearseConfig;
-import co.earthme.hearse.concurrent.WorkerThreadPoolExecutor;
-import co.earthme.hearse.concurrent.threadfactory.DefaultWorkerFactory;
+import me.earthme.moka.Moka;
+import me.earthme.moka.MokaConfig;
+import me.earthme.moka.concurrent.WorkerThreadPoolExecutor;
+import me.earthme.moka.concurrent.threadfactory.DefaultWorkerFactory;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableList.Builder;
 import com.google.common.collect.*;
@@ -20,9 +20,6 @@ import com.mojang.logging.LogUtils;
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.JsonOps;
 import io.papermc.paper.util.MCUtil;
-import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
-import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
-import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.*;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap.Entry;
 import it.unimi.dsi.fastutil.objects.*;
@@ -1253,9 +1250,9 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
     public static void tryInitIfNotInited(){
         if (!isInited.get()){
-            enabled.set(HearseConfig.getBoolean("optimizations.enable-multithreaded-tracker",true));
+            enabled.set(MokaConfig.getBoolean("optimizations.enable-multithreaded-tracker",true));
             if (enabled.get()){
-                final int threadCount = HearseConfig.getInt("workers.multithreaded-tracker-thread-count",Runtime.getRuntime().availableProcessors());
+                final int threadCount = MokaConfig.getInt("workers.multithreaded-tracker-thread-count",Runtime.getRuntime().availableProcessors());
                 concurrentTrackWorker = new WorkerThreadPoolExecutor(
                         threadCount,
                         threadCount,
@@ -1263,7 +1260,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                         TimeUnit.SECONDS,
                         new LinkedBlockingQueue<>(),
                         new DefaultWorkerFactory("tracker-concurrent"));
-                Hearse.getWorkerManager().addWorker("tracker",concurrentTrackWorker);
+                Moka.getWorkerManager().addWorker("tracker",concurrentTrackWorker);
             }
             isInited.set(true);
         }
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index d6104a27c73d8c6e15b2a667ba57d9fb49771b21..665ce1cc82f000d556cba95e802f4724a0d0851e 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -1,7 +1,6 @@
 package net.minecraft.server.level;
 
 import ca.spottedleaf.concurrentutil.executor.standard.PrioritisedExecutor;
-import co.earthme.hearse.concurrent.thread.Worker;
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.Lists;
 import com.mojang.datafixers.DataFixer;
@@ -9,8 +8,6 @@ import com.mojang.datafixers.util.Either;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMaps;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
-import it.unimi.dsi.fastutil.objects.ObjectArraySet;
-import it.unimi.dsi.fastutil.objects.ObjectSet;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.SectionPos;
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index f14c48a21111805f06e592734d54cad80898bd9a..221a7abfece8603223371070ef2b12a16eda0de9 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -1,17 +1,14 @@
 package net.minecraft.server.level;
 
 import co.aikar.timings.TimingHistory;
-import co.earthme.hearse.concurrent.thread.WorkerThread;
-import co.earthme.hearse.server.ServerEntityTickHook;
+import me.earthme.moka.server.ServerEntityTickHook;
 import com.google.common.annotations.VisibleForTesting;
-import co.aikar.timings.TimingHistory; // Paper
-import co.earthme.hearse.concurrent.thread.Worker;
+import me.earthme.moka.concurrent.thread.Worker;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
-import io.papermc.paper.util.MCUtil;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMaps;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
@@ -729,11 +726,14 @@ public class ServerLevel extends Level implements WorldGenLevel {
         if (this.dragonFight != null) {
             this.dragonFight.tick();
         }
+
+        this.tickBlockEntities();
+
         org.spigotmc.ActivationRange.activateEntities(this); // Spigot
         this.entityTickList.forEach((entity) -> {
             ServerEntityTickHook.callAsyncEntityTick(entity,this);
         });
-        this.tickBlockEntities();
+
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index c9925f873cc574013b60cff9b4c80730bfb893f6..ac9e602f8ea086b453bb5c4e7097505771a8ce66 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -737,6 +737,8 @@ public class ServerPlayer extends Player {
             if (this.server.getTickCount() % 20 == 1) {
                 this.nearbyChunkHot = this.refreshNearbyChunkHot();
 
+                //Moka start
+                /*
                 if (this.nearbyChunkHot > 330000L) {
                     if (this.isAfk) {
                         this.connection.disconnect(Component.translatable("multiplayer.disconnect.idling"), org.bukkit.event.player.PlayerKickEvent.Cause.IDLING);
@@ -747,7 +749,8 @@ public class ServerPlayer extends Player {
                             this.setRemainingFireTicks(fireTicks);
                         }
                     }
-                }
+                }*/
+                //Moka end
             }
         } else if (this.server.getTickCount() > 600) {
             bypassStartup = true;
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index eaa10c6fd180e4f4faa3db6edf4365c68d80c40e..5d795a196f62978acf937072fa37574b1f09dc7f 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -1,6 +1,6 @@
 package net.minecraft.world.entity;
 
-import co.earthme.hearse.util.EntityPositionCache;
+import me.earthme.moka.util.EntityPositionCache;
 import com.destroystokyo.paper.event.player.PlayerArmorChangeEvent; // Paper
 import com.google.common.base.Objects;
 import com.google.common.collect.ImmutableList;
@@ -124,7 +124,6 @@ import net.minecraft.world.scores.PlayerTeam;
 import org.slf4j.Logger;
 
 // CraftBukkit start
-import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Set;
 import com.google.common.base.Function;
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/NearestLivingEntitySensor.java b/src/main/java/net/minecraft/world/entity/ai/sensing/NearestLivingEntitySensor.java
index 1ab18b6a7e2a85f06d63ba21354df8431e62e45d..24106a0d5777b5afea20d0fc95281a3ab4778df9 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/NearestLivingEntitySensor.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/NearestLivingEntitySensor.java
@@ -1,6 +1,6 @@
 package net.minecraft.world.entity.ai.sensing;
 
-import co.earthme.hearse.util.EntityPositionCache;
+import me.earthme.moka.util.EntityPositionCache;
 import com.google.common.collect.ImmutableSet;
 import java.util.Comparator;
 import java.util.List;
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/PlayerSensor.java b/src/main/java/net/minecraft/world/entity/ai/sensing/PlayerSensor.java
index af6dcbd8f531705c356780cc79aa1868a10cfaf9..3a8a5dabf8d1493db23af8d8839803aef0dfcaa9 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/PlayerSensor.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/PlayerSensor.java
@@ -1,11 +1,10 @@
 package net.minecraft.world.entity.ai.sensing;
 
-import co.earthme.hearse.util.EntityPositionCache;
+import me.earthme.moka.util.EntityPositionCache;
 import com.google.common.collect.ImmutableSet;
 
 import java.util.*;
 import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.stream.Collectors;
 
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import it.unimi.dsi.fastutil.objects.ObjectLists;
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/Sensing.java b/src/main/java/net/minecraft/world/entity/ai/sensing/Sensing.java
index 58c6b1f67aedf5ab2167fd070604fc0d8f710435..94ec692e7a977c906f8276f57638293846417330 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/Sensing.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/Sensing.java
@@ -6,10 +6,14 @@ import it.unimi.dsi.fastutil.ints.IntSets;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.entity.Mob;
 
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
 public class Sensing {
     private final Mob mob;
     private final IntSet seen = IntSets.synchronize(new IntOpenHashSet());
     private final IntSet unseen = IntSets.synchronize(new IntOpenHashSet());
+    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
 
     public Sensing(Mob owner) {
         this.mob = owner;
@@ -22,21 +26,31 @@ public class Sensing {
 
     public boolean hasLineOfSight(Entity entity) {
         int i = entity.getId();
-        if (this.seen.contains(i)) {
-            return true;
-        } else if (this.unseen.contains(i)) {
-            return false;
-        } else {
-            //this.mob.level.getProfiler().push("hasLineOfSight"); // Purpur
-            boolean bl = this.mob.hasLineOfSight(entity);
-            //this.mob.level.getProfiler().pop(); // Purpur
+        this.readWriteLock.readLock().lock();
+        try {
+            if (this.seen.contains(i)) {
+                return true;
+            } else if (this.unseen.contains(i)) {
+                return false;
+            }
+        }finally {
+            this.readWriteLock.readLock().unlock();
+        }
+
+        //this.mob.level.getProfiler().push("hasLineOfSight"); // Purpur
+        boolean bl = this.mob.hasLineOfSight(entity);
+        //this.mob.level.getProfiler().pop(); // Purpur
+
+        this.readWriteLock.writeLock().lock();
+        try {
             if (bl) {
                 this.seen.add(i);
             } else {
                 this.unseen.add(i);
             }
-
             return bl;
+        }finally {
+            this.readWriteLock.writeLock().unlock();
         }
     }
 }
diff --git a/src/main/java/net/minecraft/world/entity/monster/warden/AngerManagement.java b/src/main/java/net/minecraft/world/entity/monster/warden/AngerManagement.java
index ece82743df21f0b776382821ad75dee96d0a0748..bf199786da6b790c57646b975cc47a941018d888 100644
--- a/src/main/java/net/minecraft/world/entity/monster/warden/AngerManagement.java
+++ b/src/main/java/net/minecraft/world/entity/monster/warden/AngerManagement.java
@@ -1,6 +1,7 @@
 package net.minecraft.world.entity.monster.warden;
 
 import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.Lists;
 import com.google.common.collect.Streams;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.serialization.Codec;
@@ -14,6 +15,8 @@ import java.util.Comparator;
 import java.util.List;
 import java.util.Optional;
 import java.util.UUID;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
@@ -45,6 +48,7 @@ public class AngerManagement {
     protected final Object2IntMap<Entity> angerBySuspect;
     @VisibleForTesting
     protected final Object2IntMap<UUID> angerByUuid;
+    private final Lock accessLock = new ReentrantLock();
 
     public static Codec<AngerManagement> codec(Predicate<Entity> suspectPredicate) {
         return RecordCodecBuilder.create((instance) -> {
@@ -66,56 +70,59 @@ public class AngerManagement {
     }
 
     private List<Pair<UUID, Integer>> createUuidAngerPairs() {
-        return Streams.<Pair<UUID, Integer>>concat(this.suspects.stream().map((suspect) -> {
-            return Pair.of(suspect.getUUID(), this.angerBySuspect.getInt(suspect));
-        }), this.angerByUuid.object2IntEntrySet().stream().map((suspect) -> {
+        return Streams.<Pair<UUID, Integer>>concat(this.suspects.stream().map((suspect) -> Pair.of(suspect.getUUID(), this.angerBySuspect.getInt(suspect))), this.angerByUuid.object2IntEntrySet().stream().map((suspect) -> {
             return Pair.of(suspect.getKey(), suspect.getIntValue());
         })).collect(Collectors.toList());
     }
 
     public void tick(ServerLevel world, Predicate<Entity> suspectPredicate) {
-        --this.conversionDelay;
-        if (this.conversionDelay <= 0) {
-            this.convertFromUuids(world);
-            this.conversionDelay = 2;
+        if (!this.accessLock.tryLock()){
+            return;
         }
+        try {
+            --this.conversionDelay;
+            if (this.conversionDelay <= 0) {
+                this.convertFromUuids(world);
+                this.conversionDelay = 2;
+            }
 
-        ObjectIterator<Object2IntMap.Entry<UUID>> objectIterator = this.angerByUuid.object2IntEntrySet().iterator();
+            ObjectIterator<Object2IntMap.Entry<UUID>> objectIterator = this.angerByUuid.object2IntEntrySet().iterator();
 
-        while(objectIterator.hasNext()) {
-            Object2IntMap.Entry<UUID> entry = objectIterator.next();
-            int i = entry.getIntValue();
-            if (i <= 1) {
-                objectIterator.remove();
-            } else {
-                entry.setValue(i - 1);
+            while(objectIterator.hasNext()) {
+                Object2IntMap.Entry<UUID> entry = objectIterator.next();
+                int i = entry.getIntValue();
+                if (i <= 1) {
+                    objectIterator.remove();
+                } else {
+                    entry.setValue(i - 1);
+                }
             }
-        }
 
-        ObjectIterator<Object2IntMap.Entry<Entity>> objectIterator2 = this.angerBySuspect.object2IntEntrySet().iterator();
+            ObjectIterator<Object2IntMap.Entry<Entity>> objectIterator2 = this.angerBySuspect.object2IntEntrySet().iterator();
 
-        while(objectIterator2.hasNext()) {
-            Object2IntMap.Entry<Entity> entry2 = objectIterator2.next();
-            int j = entry2.getIntValue();
-            Entity entity = entry2.getKey();
-            Entity.RemovalReason removalReason = entity.getRemovalReason();
-            if (j > 1 && suspectPredicate.test(entity) && removalReason == null) {
-                entry2.setValue(j - 1);
-            } else {
-                this.suspects.remove(entity);
-                objectIterator2.remove();
-                if (j > 1 && removalReason != null) {
-                    switch (removalReason) {
-                        case CHANGED_DIMENSION:
-                        case UNLOADED_TO_CHUNK:
-                        case UNLOADED_WITH_PLAYER:
-                            this.angerByUuid.put(entity.getUUID(), j - 1);
+            while(objectIterator2.hasNext()) {
+                Object2IntMap.Entry<Entity> entry2 = objectIterator2.next();
+                int j = entry2.getIntValue();
+                Entity entity = entry2.getKey();
+                Entity.RemovalReason removalReason = entity.getRemovalReason();
+                if (j > 1 && suspectPredicate.test(entity) && removalReason == null) {
+                    entry2.setValue(j - 1);
+                } else {
+                    this.suspects.remove(entity);
+                    objectIterator2.remove();
+                    if (j > 1 && removalReason != null) {
+                        switch (removalReason) {
+                            case CHANGED_DIMENSION, UNLOADED_TO_CHUNK, UNLOADED_WITH_PLAYER ->
+                                    this.angerByUuid.put(entity.getUUID(), j - 1);
+                        }
                     }
                 }
             }
-        }
 
-        this.sortAndUpdateHighestAnger();
+            this.sortAndUpdateHighestAnger();
+        }finally {
+            this.accessLock.unlock();
+        }
     }
 
     private void sortAndUpdateHighestAnger() {
@@ -124,7 +131,6 @@ public class AngerManagement {
         if (this.suspects.size() == 1) {
             this.highestAnger = this.angerBySuspect.getInt(this.suspects.get(0));
         }
-
     }
 
     private void convertFromUuids(ServerLevel world) {
@@ -144,46 +150,64 @@ public class AngerManagement {
     }
 
     public int increaseAnger(Entity entity, int amount) {
-        boolean bl = !this.angerBySuspect.containsKey(entity);
-        int i = this.angerBySuspect.computeInt(entity, (suspect, anger) -> {
-            return Math.min(150, (anger == null ? 0 : anger) + amount); // Paper - diff on change
-        });
-        if (bl) {
-            int j = this.angerByUuid.removeInt(entity.getUUID());
-            i += j;
-            this.angerBySuspect.put(entity, i);
-            this.suspects.add(entity);
-        }
+        this.accessLock.lock();
+        try {
+            boolean bl = !this.angerBySuspect.containsKey(entity);
+            int i = this.angerBySuspect.computeInt(entity, (suspect, anger) -> {
+                return Math.min(150, (anger == null ? 0 : anger) + amount); // Paper - diff on change
+            });
+            if (bl) {
+                int j = this.angerByUuid.removeInt(entity.getUUID());
+                i += j;
+                this.angerBySuspect.put(entity, i);
+                this.suspects.add(entity);
+            }
 
-        this.sortAndUpdateHighestAnger();
-        return i;
+            this.sortAndUpdateHighestAnger();
+            return i;
+        }finally {
+            this.accessLock.unlock();
+        }
     }
 
     public void clearAnger(Entity entity) {
-        this.angerBySuspect.removeInt(entity);
-        this.suspects.remove(entity);
-        this.sortAndUpdateHighestAnger();
+        this.accessLock.lock();
+        try {
+            this.angerBySuspect.removeInt(entity);
+            this.suspects.remove(entity);
+            this.sortAndUpdateHighestAnger();
+        }finally {
+            this.accessLock.unlock();
+        }
     }
 
     @Nullable
     private Entity getTopSuspect() {
-        return this.suspects.stream().filter(this.filter).findFirst().orElse((Entity)null);
+        List<Entity> cop;
+        this.accessLock.lock();
+        try {
+            cop = Lists.newArrayList(this.suspects);
+        }finally {
+            this.accessLock.unlock();
+        }
+        return cop.stream().filter(this.filter).findFirst().orElse((Entity)null);
     }
 
     public int getActiveAnger(@Nullable Entity entity) {
-        return entity == null ? this.highestAnger : this.angerBySuspect.getInt(entity);
+        this.accessLock.lock();
+        try {
+            return entity == null ? this.highestAnger : this.angerBySuspect.getInt(entity);
+        }finally {
+            this.accessLock.unlock();
+        }
     }
 
     public Optional<LivingEntity> getActiveEntity() {
-        return Optional.ofNullable(this.getTopSuspect()).filter((suspect) -> {
-            return suspect instanceof LivingEntity;
-        }).map((suspect) -> {
-            return (LivingEntity)suspect;
-        });
+        return Optional.ofNullable(this.getTopSuspect()).filter((suspect) -> suspect instanceof LivingEntity).map((suspect) -> (LivingEntity)suspect);
     }
 
     @VisibleForTesting
-    protected static record Sorter(AngerManagement angerManagement) implements Comparator<Entity> {
+    protected record Sorter(AngerManagement angerManagement) implements Comparator<Entity> {
         @Override
         public int compare(Entity entity, Entity entity2) {
             if (entity.equals(entity2)) {
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 0da360482f9d7aa151ab980d91c492765d7a038e..d59c1d0f5b8c8b6f2e9effcb3fd516f4bbd6108f 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -1,6 +1,6 @@
 package net.minecraft.world.level;
 
-import co.earthme.hearse.concurrent.thread.Worker;
+import me.earthme.moka.concurrent.thread.Worker;
 import com.destroystokyo.paper.event.server.ServerExceptionEvent;
 import com.destroystokyo.paper.exception.ServerInternalException;
 import com.google.common.collect.Lists;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 280f8015f6e638e569dca39b94695d3fce9118f5..82ee62865240f5f383aa72699a722b3a53ab20bc 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1,7 +1,6 @@
 package org.bukkit.craftbukkit;
 
-import co.earthme.hearse.HearseConfig;
-import co.earthme.hearse.concurrent.thread.Worker;
+import me.earthme.moka.concurrent.thread.Worker;
 import com.google.common.base.Charsets;
 import com.google.common.base.Function;
 import com.google.common.base.Preconditions;
@@ -236,7 +235,6 @@ import org.bukkit.plugin.PluginManager;
 import org.bukkit.plugin.ServicesManager;
 import org.bukkit.plugin.SimplePluginManager;
 import org.bukkit.plugin.SimpleServicesManager;
-import org.bukkit.plugin.java.JavaPluginLoader;
 import org.bukkit.plugin.messaging.Messenger;
 import org.bukkit.plugin.messaging.StandardMessenger;
 import org.bukkit.potion.Potion;
